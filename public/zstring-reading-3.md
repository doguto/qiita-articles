---
title: ZStringを読もう(3) Utf16ValuesStringBuilder
tags:
  - C#
  - OSS
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---

どうもKutoです。
ということで、ZStringを読もうの第3回です。
前回はinitial commit時点でのディレクトリ構造やZString.csの紹介をしましたが、今回は実際にゼロアロケーション構築の根幹をなしているUtf16ValuesStringBuilderの実装を読んでいきたいと思います。

## Utf16ValuesStringBuilder.cs

以下のように`Utf16ValuesStringBuilder`には`partial`修飾子が付されており、複数ファイルにその実装がまたがるようになっています。
これは前回ちらっと話題に出したT4テンプレートでコードを生成させやすいように設定しているのだと考えられます。

よってまずは一番根幹の実装が詰まっている`Utf16ValuesStringBuilder.cs`を確認していきます。

```cs
namespace Cysharp.Text
{
    public ref partial struct Utf16ValueStringBuilder
    {
```

さあ最初の4行です。namespaceと構造体を宣言しているだけのたった4行ではありますが、ここからもうゼロアロケーションへの取り組みが見て取れます。

### classではなくstruct

通常このようなUtility系を組むときはclassを用いると思いますが、structを用いているというのが大きな工夫ポイントです。
何故classではいけないのか。これを説明するにはclassとstructの違いをしっかりと認識していなければいけません。

**classとstructの違い**
この2つ、違いをよく分からずに使っている人も多いのでしょうか？

「structは値型でclassは参照型である」
structとclassの違いをC#erに聞いたとき、ここまでは多くの方が回答として出せると思います。実際にこれは正しいですし、これに全てが詰まっているでしょう。
しかしでは値型と参照型の違いは？ この疑問に対しては答えられるでしょうか。

**値型と参照型の違い**
ここら辺の知識は曖昧な人も多いのではないでしょうか。自分も正直曖昧でした。
自分が認識していた違いは以下のようなものです。

|          | class |           struct             |
| -------- | ----- | ---------------------------- |
| 初期値    | null | 各メンバ変数にデフォルト値が入る | 
| new演算子 | 必要 |            不要                |
| 継承     |  可能 |           不可能               |

まとめれば、「継承できるからclass使っておけば良いんでしょ？」これが私の元々の認識でした。
実際パフォーマンスをそこまで求めらない環境ではこの認識でも特に問題は生じない気がします。
しかし本ライブラリのようなパフォーマンスを強く求める場においては、この認識では全く足りません。それぞれに対しより根本的な実装内容を把握しなければいけないのです。

**メモリ領域の違い**
structとclass、つまり値型と参照型の違いの根本は使用されるメモリ領域の違いに行きつきます。
インスタンスを生成した際にそのインスタンスが保存されるメモリの領域が両者で異なるのです。

具体的に説明すると、構造体の場合インスタンスはメモリ上の**スタック**という領域に保存されます。これは他のint型やbool型などといったプリミティブ型の変数が格納される領域と一緒で、プログラミング上の変数が直接データの値を保存し持ちます。

それに対しクラスの場合、インスタンスはメモリ上の**ヒープ**という領域に保存されます。ヒープはプログラミング上から直接アクセスすることの出来ない領域です。なのでインスタンスが代入された変数は直接インスタンスのデータを持つことが出来ません。
そのためクラス等の参照型の変数を持つ際には、ヒープ上の該当データが保存されたメモリのアドレスをスタックに保存し、これを変数で持つのです。

そしてこのメモリのヒープ領域にデータを確保することは継承を可能にするなど多くのメリットがある反面、パフォーマンス的なデメリットが存在します。デメリットとは、つまり**メモリアロケーション**です。
メモリアロケーションとは単にデータを保存するための領域をメモリ上に確保することですが、アロケーションの中でも特にヒープアロケーションは注意をする必要があります。
ヒープアロケーションは確保／解放やGCの対象になるためコストが高く、頻繁な小さな割り当ては性能低下とGC負荷の増加を招いてしまうのです。


ZStringはstring操作のゼロアロケーション化を目的としたライブラリです。よってその実装もクラスではなく構造体にし、アロケーションを最大限減らそうとしているのでしょう。
自分だったら何も考えずにクラスを使いそうなものですが、こういったところでもゼロアロケーションへの取り組みが見れるのは流石としか言いようがありませんね。

### ref修飾子

上述したように基本的にstructはスタック領域に割り当てられます。しかし、以下のような場合はどうでしょう？

```cs
struct Hoge
{
    int bar;
}

class Fuga
{
    Hoge hoge;
}
```

クラスはヒープ領域に割り当てられると先ほど言いました。従ってこの場合Hoge型のメンバ変数hogeはスタック領域ではなくヒープ領域に割り当てられてしまいます。
つまり、わかるでしょうか。先ほどの構造体に関する解説は少し正確ではありません。構造体はスタック領域に問答無用で割り当てられるのではなく、その構造体の変数が所属しているスコープで扱われているメモリ領域に割り当てられるということです。

しかしこのライブラリの掲げる目標はゼロアロケーションです。こんなのでヒープ領域のアロケーションが発生してはいけませんよね。
このようにどんな場合でもヒープ領域へのアロケーションを防ぐため、C#では`ref`という修飾子を使ってヒープアロケーションを禁止することが出来ます。

```cs
public ref partial struct Utf16ValueStringBuilder
```

このように`Utf16ValueStringBuilder`にはref修飾子を付けることで上述したような場合のヒープアロケーションを禁止しています。
ちなみに禁止というのはコンパイルエラーになるという意味です。つまり、以下はエラーになります。

```cs
class Hoge
{
    Utf16ValueStringBuilder builder;  // エラー
}
```

ここまでヒープアロケーションを避けるとは徹底していますよね。僕だったらこれでアロケーションが発生するのは使用者のせいだし～と考えて何もしません。

ちなみにここで使用されているref修飾子ですが、実はこれが本来の用途というわけではありません。詳しくは本筋とずれるため[こちらの記事](https://ufcpp.net/study/csharp/sp_ref.html)を見て欲しいですが、これは元は参照渡しのために実装された修飾子です。元々参照渡し用に実装されたものを`ref struct`の形で流用したんですね。
